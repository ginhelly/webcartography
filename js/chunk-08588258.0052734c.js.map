{"version":3,"sources":["webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/core-js/modules/es.array.reduce.js","webpack:///./node_modules/@turf/bbox/index.js","webpack:///./node_modules/@turf/boolean-point-in-polygon/index.js","webpack:///./node_modules/@turf/boolean-contains/index.js","webpack:///./node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/boolean-point-on-line/index.js","webpack:///./src/views/Schools.vue?2208","webpack:///./node_modules/core-js/internals/array-method-is-strict.js","webpack:///./src/views/Schools.vue?1f5f","webpack:///./src/scripts/fetch_geojson.js","webpack:///src/views/Schools.vue","webpack:///./src/views/Schools.vue?deca","webpack:///./src/views/Schools.vue?e7bb","webpack:///./node_modules/core-js/internals/array-reduce.js","webpack:///./node_modules/core-js/modules/es.array.map.js","webpack:///./node_modules/@turf/helpers/index.js"],"names":["Object","defineProperty","exports","value","helpers_1","getCoord","coord","Error","Array","isArray","type","geometry","coordinates","length","getCoords","coords","containsNumber","isNumber","geojsonType","name","featureOf","feature","collectionOf","featureCollection","_i","_a","features","getGeom","geojson","getType","$","$reduce","left","arrayMethodIsStrict","arrayMethodUsesToLength","CHROME_VERSION","IS_NODE","STRICT_METHOD","USES_TO_LENGTH","1","CHROME_BUG","target","proto","forced","reduce","callbackfn","this","arguments","undefined","meta_1","bbox","result","Infinity","coordEach","default","invariant_1","booleanPointInPolygon","point","polygon","options","pt","geom","polys","inBBox","insidePoly","i","inRing","ignoreBoundary","inHole","k","ring","isInside","slice","j","xi","yi","xj","yj","onBoundary","intersect","__importDefault","mod","__esModule","bbox_1","boolean_point_in_polygon_1","boolean_point_on_line_1","booleanContains","feature1","feature2","geom1","geom2","type1","type2","coords1","coords2","compareCoords","isPointInMultiPoint","isMultiPointInMultiPoint","ignoreEndVertices","isLineOnLine","isMultiPointOnLine","isLineInPoly","isPolyInPoly","isMultiPointInPoly","multiPoint","output","multiPoint1","multiPoint2","coord2","matchFound","_b","_c","coord1","lineString","haveFoundInteriorPoint","lineString1","lineString2","linestring","polyBbox","lineBbox","doBBoxOverlap","midPoint","getMidpoint","poly1Bbox","poly2Bbox","coords_1","ring_1","bbox1","bbox2","pair1","pair2","helpers","callback","excludeWrapCoord","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordReduce","initialValue","previousValue","currentCoord","propEach","properties","propReduce","currentProperties","featureEach","featureReduce","currentFeature","coordAll","push","geomEach","g","featureProperties","featureBBox","featureId","id","geomReduce","currentGeometry","flattenEach","coordinate","flattenReduce","segmentEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentReduce","started","lineEach","lineReduce","currentLine","findSegment","isObject","findPoint","booleanPointOnLine","line","ptCoords","lineCoords","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","excludeBoundary","x","y","x1","y1","x2","y2","dxc","dyc","dxl","dyl","cross","Math","abs","fails","module","METHOD_NAME","argument","method","call","render","_vm","_h","$createElement","_self","_v","attrs","staticRenderFns","prompt","fetch","response","json","iconRetinaUrl","iconUrl","shadowUrl","data","districts","schools","map","markers","maxSchools","minSchools","methods","initMap","attribution","addTooltip","layer","bindTooltip","tooltip","rgbToHex","r","b","toString","getColorComponent","lowerTreshold","offsetInt","getColor","addDistricts","onEachFeature","ref","style","fillColor","cntSchools","weight","opacity","color","dashArray","fillOpacity","districtsGroup","addTo","addSchools","geoJsonLayer","bindPopup","addLayer","countSchoolsInside","schoolsByDistrict","component","aFunction","toObject","IndexedObject","toLength","createMethod","IS_RIGHT","that","argumentsLength","memo","O","self","index","TypeError","right","$map","arrayMethodHasSpeciesSupport","HAS_SPECIES_SUPPORT","feat","multiLineString","multiPolygon","points","coordinates_1","polygons","lineStrings","fc","geometryCollection","round","num","precision","multiplier","pow","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","lengthToDegrees","radiansToDegrees","bearingToAzimuth","bearing","angle","degrees","PI","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","areaFactors","finalFactor","isNaN","test","input","constructor","validateBBox","forEach","validateId","indexOf","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","earthRadius","centimeters","centimetres","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","acres"],"mappings":"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","file":"js/chunk-08588258.0052734c.js","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","'use strict';\nvar $ = require('../internals/export');\nvar $reduce = require('../internals/array-reduce').left;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');\nvar CHROME_VERSION = require('../internals/engine-v8-version');\nvar IS_NODE = require('../internals/engine-is-node');\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\nvar USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nfunction booleanContains(feature1, feature2) {\n    var geom1 = invariant_1.getGeom(feature1);\n    var geom2 = invariant_1.getGeom(feature2);\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    var coords1 = invariant_1.getCoords(feature1);\n    var coords2 = invariant_1.getCoords(feature2);\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexports.default = booleanContains;\nfunction isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isPointInMultiPoint = isPointInMultiPoint;\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\nfunction isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexports.isMultiPointOnLine = isMultiPointOnLine;\nfunction isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInPoly = isMultiPointInPoly;\nfunction isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexports.isLineOnLine = isLineOnLine;\nfunction isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = bbox_1.default(polygon);\n    var lineBbox = bbox_1.default(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (boolean_point_in_polygon_1.default({ type: \"Point\", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = bbox_1.default(feature1);\n    var poly2Bbox = bbox_1.default(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = invariant_1.getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.isPolyInPoly = isPolyInPoly;\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexports.compareCoords = compareCoords;\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexports.getMidpoint = getMidpoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--6-oneOf-1-2!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Schools.vue?vue&type=style&index=0&id=6751b9a4&scoped=true&lang=css&\"","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('h3',[_vm._v(\"Школы г. Ижевска\")]),_c('div',{attrs:{\"id\":\"map\"}}),_c('v-row',[_c('v-col',{attrs:{\"cols\":\"2\"}}),_c('v-col',{attrs:{\"cols\":\"8\"}},[_c('p',[_vm._v(\" Данная карта показывает школы города по районам. При наведении на район появляется tooltip с названием района и количеством школ в нём. Это число рассчитывается исходя из географического размещения точки внутри или вне полигона района. Данные по школам взяты с OSM и могут быть неточными. Карта будет доделываться.\"),_c('br'),_vm._v(\" Вдохновлено \"),_c('a',{attrs:{\"href\":\"https://leafletjs.com/examples/choropleth/\"}},[_vm._v(\"этой статьёй\")]),_vm._v(\".\"),_c('br'),_vm._v(\" Отличие от этого примера в том, что здесь число школ внутри районов Ижевска рассчитывается на лету при загрузке и обработке geoJSON-файла, т.е. в перспективе есть возможность здесь же, при определенных действиях пользователя перекрашивать заливку полигона (цвет заливки тоже рассчитывается на лету). Для проверки, находится ли школа внутри полигона, использовалась библиотека \"),_c('a',{attrs:{\"href\":\"https://turfjs.org/docs/#booleanContains\"}},[_vm._v(\"Turf.js\")])])]),_c('v-col',{attrs:{\"cols\":\"2\"}})],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default async (prompt) => {\n  const response = await fetch(prompt)\n  const geojson = await response.json()\n  return geojson\n}\n","<template>\n  <div>\n    <h3>Школы г. Ижевска</h3>\n    <div id='map'>\n    </div>\n    <v-row>\n      <v-col cols=\"2\"></v-col>\n      <v-col cols=\"8\">\n        <p>\n          Данная карта показывает школы города по районам. При наведении на район появляется\n          tooltip с названием района и количеством школ в нём. Это число рассчитывается\n          исходя из географического размещения точки внутри или вне полигона района.\n          Данные по школам взяты с OSM и могут быть неточными. Карта будет доделываться.<br>\n          Вдохновлено <a href=\"https://leafletjs.com/examples/choropleth/\">этой статьёй</a>.<br>\n          Отличие от этого примера в том, что здесь число школ внутри районов Ижевска\n          рассчитывается на лету при загрузке и обработке geoJSON-файла, т.е. в перспективе\n          есть возможность здесь же, при определенных действиях пользователя перекрашивать\n          заливку полигона (цвет заливки тоже рассчитывается на лету).\n          Для проверки, находится ли школа внутри полигона, использовалась библиотека\n          <a href=\"https://turfjs.org/docs/#booleanContains\">Turf.js</a>\n        </p>\n      </v-col>\n      <v-col cols=\"2\"></v-col>\n    </v-row>\n  </div>\n</template>\n\n<script>\nimport L from 'leaflet'\nimport 'leaflet/dist/leaflet.css'\nimport 'leaflet.markercluster/dist/MarkerCluster.css'\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css'\nimport 'leaflet.markercluster/dist/leaflet.markercluster.js'\nimport booleanContains from '@turf/boolean-contains'\nimport FetchGeojson from '../scripts/fetch_geojson'\n\ndelete L.Icon.Default.prototype._getIconUrl\nL.Icon.Default.mergeOptions({\n  iconRetinaUrl: require('leaflet/dist/images/marker-icon-2x.png'),\n  iconUrl: require('leaflet/dist/images/marker-icon.png'),\n  shadowUrl: require('leaflet/dist/images/marker-shadow.png')\n})\n\nexport default {\n  name: 'Schools',\n  data () {\n    return {\n      districts: null,\n      schools: null,\n      map: null,\n      markers: null,\n      maxSchools: 0,\n      minSchools: 0\n    }\n  },\n  methods: {\n    initMap () {\n      const izhevsk = [56.850671, 53.204795]\n      /// const zero = [0.0, 0.0]\n      const map = L.map('map')\n        .setView(izhevsk, 11)\n      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OSM</a> contributors'\n      }).addTo(map)\n      this.map = map\n    },\n    addTooltip (feature, layer) {\n      if (feature.properties &&\n        feature.properties.cntSchools &&\n        feature.properties.name\n      ) {\n        const tooltip = feature.properties.name + ', ' + feature.properties.cntSchools.toString()\n        layer.bindTooltip(tooltip)\n      }\n    },\n    rgbToHex (r, g, b) {\n      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)\n    },\n    getColorComponent (i, upperTreshold, lowerTreshold) {\n      const offset = (i - this.minSchools) / (this.maxSchools - this.minSchools)\n      const offset2 = 1 - offset\n      const offsetInt = Math.round((upperTreshold - lowerTreshold) * offset2)\n      return lowerTreshold + offsetInt\n    },\n    getColor (i) {\n      const r = this.getColorComponent(i, 239, 117)\n      const g = this.getColorComponent(i, 237, 107)\n      const b = this.getColorComponent(i, 245, 177)\n      return this.rgbToHex(r, g, b)\n    },\n    addDistricts () {\n      const ref = this\n      const districtsGroup = L.geoJSON(this.districts, {\n        onEachFeature: ref.addTooltip,\n        style: function (feature) {\n          return {\n            fillColor: ref.getColor(feature.properties.cntSchools),\n            weight: 2,\n            opacity: 1,\n            color: 'white',\n            dashArray: '3',\n            fillOpacity: 0.7\n          }\n        }\n      })\n      districtsGroup.addTo(this.map)\n    },\n    addSchools () {\n      const markers = L.markerClusterGroup()\n      var geoJsonLayer = L.geoJson(this.schools, {\n        onEachFeature: function (feature, layer) {\n          layer.bindPopup(feature.properties.name)\n        }\n      })\n      markers.addLayer(geoJsonLayer)\n      this.map.addLayer(markers)\n      this.markers = markers\n    },\n    countSchoolsInside () {\n      const schoolsByDistrict = []\n      for (const district of this.districts.features) {\n        let total = 0\n        for (const school of this.schools.features) {\n          if (booleanContains(district, school)) {\n            total += 1\n          }\n        }\n        district.properties.cntSchools = total\n        schoolsByDistrict.push(total)\n      }\n      this.maxSchools = schoolsByDistrict.reduce((prev, i) => i > prev ? i : prev)\n      this.minSchools = schoolsByDistrict.reduce((prev, i) => i < prev ? i : prev)\n    }\n  },\n  async mounted () {\n    this.districts = await FetchGeojson('data/izhevsk_districts3.geojson')\n    this.schools = await FetchGeojson('data/izhevsk_schools3.geojson')\n    this.countSchoolsInside()\n    this.initMap()\n    this.addDistricts()\n    this.addSchools()\n  }\n}\n</script>\n\n<style scoped>\nh3 {\n  text-align: center;\n}\n\n#map {\n  width: 100%;\n  height: 90vh;\n}\n</style>\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Schools.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Schools.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Schools.vue?vue&type=template&id=6751b9a4&scoped=true&\"\nimport script from \"./Schools.vue?vue&type=script&lang=js&\"\nexport * from \"./Schools.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Schools.vue?vue&type=style&index=0&id=6751b9a4&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"6751b9a4\",\n  null\n  \n)\n\nexport default component.exports","var aFunction = require('../internals/a-function');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\nvar toLength = require('../internals/to-length');\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aFunction(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.reduce` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\nvar arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n// FF49- issue\nvar USES_TO_LENGTH = arrayMethodUsesToLength('map');\n\n// `Array.prototype.map` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n"],"sourceRoot":""}